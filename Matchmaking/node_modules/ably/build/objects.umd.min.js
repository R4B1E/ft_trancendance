/*@license Copyright 2015-2022 Ably Real-time Ltd (ably.com)

Ably JavaScript Library v2.11.1
https://github.com/ably/ably-js

Released under the Apache Licence v2.0*/(function (g, f) {
    if ("object" == typeof exports && "object" == typeof module) {
      module.exports = f();
    } else if ("function" == typeof define && define.amd) {
      define([], f);
    } else if ("object" == typeof exports) {
      exports["AblyObjectsPlugin"] = f();
    } else {
      g["AblyObjectsPlugin"] = f();
    }
  }(this, () => {
var exports = {};
var module = { exports };
"use strict";var A=Object.defineProperty,H=Object.defineProperties,Q=Object.getOwnPropertyDescriptor,X=Object.getOwnPropertyDescriptors,ee=Object.getOwnPropertyNames,w=Object.getOwnPropertySymbols;var $=Object.prototype.hasOwnProperty,z=Object.prototype.propertyIsEnumerable;var k=(n,t)=>{if(t=Symbol[n])return t;throw Error("Symbol."+n+" is not defined")};var W=(n,t,e)=>t in n?A(n,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):n[t]=e,j=(n,t)=>{for(var e in t||(t={}))$.call(t,e)&&W(n,e,t[e]);if(w)for(var e of w(t))z.call(t,e)&&W(n,e,t[e]);return n},m=(n,t)=>H(n,X(t));var K=(n,t)=>{var e={};for(var i in n)$.call(n,i)&&t.indexOf(i)<0&&(e[i]=n[i]);if(n!=null&&w)for(var i of w(n))t.indexOf(i)<0&&z.call(n,i)&&(e[i]=n[i]);return e};var te=(n,t)=>{for(var e in t)A(n,e,{get:t[e],enumerable:!0})},ie=(n,t,e,i)=>{if(t&&typeof t=="object"||typeof t=="function")for(let a of ee(t))!$.call(n,a)&&a!==e&&A(n,a,{get:()=>t[a],enumerable:!(i=Q(t,a))||i.enumerable});return n};var ae=n=>ie(A({},"__esModule",{value:!0}),n);var se=function(n,t){this[0]=n,this[1]=t};var P=n=>{var t=n[k("asyncIterator")],e=!1,i,a={};return t==null?(t=n[k("iterator")](),i=s=>a[s]=r=>t[s](r)):(t=t.call(n),i=s=>a[s]=r=>{if(e){if(e=!1,s==="throw")throw r;return r}return e=!0,{done:!1,value:new se(new Promise(o=>{var c=t[s](r);if(!(c instanceof Object))throw TypeError("Object expected");o(c)}),1)}}),a[k("iterator")]=()=>a,i("next"),"throw"in t?i("throw"):a.throw=s=>{throw s},"return"in t&&i("return"),a};var oe={};te(oe,{ObjectMessage:()=>b,Objects:()=>E,WireObjectMessage:()=>v,default:()=>re});module.exports=ae(oe);function F(n,t,e,i){var s,r,o,c,p,l,u,f,g,C,L,D;let a=Object.assign(new v(t,e),G(n));return(r=(s=n.object)==null?void 0:s.map)!=null&&r.entries&&(a.object.map.entries=B(n.object.map.entries,i)),(p=(c=(o=n.object)==null?void 0:o.createOp)==null?void 0:c.map)!=null&&p.entries&&(a.object.createOp.map.entries=B(n.object.createOp.map.entries,i)),(f=(u=(l=n.object)==null?void 0:l.createOp)==null?void 0:u.mapOp)!=null&&f.data&&(a.object.createOp.mapOp.data=V(n.object.createOp.mapOp.data,i)),(C=(g=n.operation)==null?void 0:g.map)!=null&&C.entries&&(a.operation.map.entries=B(n.operation.map.entries,i)),(D=(L=n.operation)==null?void 0:L.mapOp)!=null&&D.data&&(a.operation.mapOp.data=V(n.operation.mapOp.data,i)),a}function B(n,t){return Object.entries(n).reduce((e,i)=>{let[a,s]=i,r=s.data?V(s.data,t):void 0;return e[a]=m(j({},s),{data:r}),e},{})}function V(n,t){return t(n)}function x(n,t){let i=b.fromValues({operation:n},t.Utils,t.MessageEncoding).encode(t),{operation:a}=i.encodeForWire(t.Utils.Format.json);return JSON.stringify(a)}function J(n,t){let e="["+t;for(let i in n)n[i]===void 0||i==="_utils"||i==="_messageEncoding"||(i==="operation"||i==="object"||i==="extras"?e+=`; ${i}=${JSON.stringify(n[i])}`:e+=`; ${i}=${n[i]}`);return e+="]",e}function G(n){let t={id:n.id,clientId:n.clientId,connectionId:n.connectionId,timestamp:n.timestamp,serial:n.serial,serialTimestamp:n.serialTimestamp,siteCode:n.siteCode};return n.operation&&(t.operation=JSON.parse(JSON.stringify(n.operation))),n.object&&(t.object=JSON.parse(JSON.stringify(n.object))),n.extras&&(t.extras=JSON.parse(JSON.stringify(n.extras))),t}var b=class n{constructor(t,e){this._utils=t;this._messageEncoding=e}static fromValues(t,e,i){return Object.assign(new n(e,i),t)}static fromValuesArray(t,e,i){return t.map(a=>n.fromValues(a,e,i))}encode(t){let e=i=>{let a={objectId:i.objectId};return t.Platform.BufferUtils.isBuffer(i.value)?a.bytes=i.value:typeof i.value=="string"?a.string=i.value:typeof i.value=="boolean"?a.boolean=i.value:typeof i.value=="number"?a.number=i.value:typeof i.value=="object"&&i.value!==null&&(a.json=JSON.stringify(i.value)),a};return F(this,this._utils,this._messageEncoding,e)}toString(){return J(this,"ObjectMessage")}},v=class n{constructor(t,e){this._utils=t;this._messageEncoding=e}static fromValues(t,e,i){return Object.assign(new n(e,i),t)}static fromValuesArray(t,e,i){return t.map(a=>n.fromValues(a,e,i))}encodeForWire(t){let e=i=>{if(i.bytes!=null){let a=this._messageEncoding.encodeDataForWire(i.bytes,null,t);return m(j({},i),{bytes:a.data})}return j({},i)};return F(this,this._utils,this._messageEncoding,e)}decode(t,e){var a,s,r,o,c,p,l,u,f,g,C,L;let i=Object.assign(new b(this._utils,this._messageEncoding),G(this));try{(s=(a=this.object)==null?void 0:a.map)!=null&&s.entries&&(i.object.map.entries=this._decodeMapEntries(this.object.map.entries,t,e)),(c=(o=(r=this.object)==null?void 0:r.createOp)==null?void 0:o.map)!=null&&c.entries&&(i.object.createOp.map.entries=this._decodeMapEntries(this.object.createOp.map.entries,t,e)),(u=(l=(p=this.object)==null?void 0:p.createOp)==null?void 0:l.mapOp)!=null&&u.data&&(i.object.createOp.mapOp.data=this._decodeObjectData(this.object.createOp.mapOp.data,t,e)),(g=(f=this.operation)==null?void 0:f.map)!=null&&g.entries&&(i.operation.map.entries=this._decodeMapEntries(this.operation.map.entries,t,e)),(L=(C=this.operation)==null?void 0:C.mapOp)!=null&&L.data&&(i.operation.mapOp.data=this._decodeObjectData(this.operation.mapOp.data,t,e))}catch(D){t.Logger.logAction(t.logger,t.Logger.LOG_ERROR,"WireObjectMessage.decode()",this._utils.inspectError(D))}return i}toJSON(){let t=arguments.length>0?this._utils.Format.json:this._utils.Format.msgpack,s=this.encodeForWire(t),{_utils:e,_messageEncoding:i}=s;return K(s,["_utils","_messageEncoding"])}toString(){return J(this,"WireObjectMessage")}getMessageSize(){var e,i;let t=0;return t+=(i=(e=this.clientId)==null?void 0:e.length)!=null?i:0,this.operation&&(t+=this._getObjectOperationSize(this.operation)),this.object&&(t+=this._getObjectStateSize(this.object)),this.extras&&(t+=JSON.stringify(this.extras).length),t}_getObjectOperationSize(t){let e=0;return t.mapOp&&(e+=this._getMapOpSize(t.mapOp)),t.counterOp&&(e+=this._getCounterOpSize(t.counterOp)),t.map&&(e+=this._getObjectMapSize(t.map)),t.counter&&(e+=this._getObjectCounterSize(t.counter)),e}_getObjectStateSize(t){let e=0;return t.map&&(e+=this._getObjectMapSize(t.map)),t.counter&&(e+=this._getObjectCounterSize(t.counter)),t.createOp&&(e+=this._getObjectOperationSize(t.createOp)),e}_getObjectMapSize(t){var i;let e=0;return Object.entries((i=t.entries)!=null?i:{}).forEach(([a,s])=>{var r;e+=(r=a==null?void 0:a.length)!=null?r:0,s&&(e+=this._getMapEntrySize(s))}),e}_getObjectCounterSize(t){return t.count==null?0:8}_getMapEntrySize(t){let e=0;return t.data&&(e+=this._getObjectDataSize(t.data)),e}_getMapOpSize(t){var i,a;let e=0;return e+=(a=(i=t.key)==null?void 0:i.length)!=null?a:0,t.data&&(e+=this._getObjectDataSize(t.data)),e}_getCounterOpSize(t){return t.amount==null?0:8}_getObjectDataSize(t){let e=0;return t.boolean!=null&&(e+=this._utils.dataSizeBytes(t.boolean)),t.bytes!=null&&(e+=this._utils.dataSizeBytes(t.bytes)),t.number!=null&&(e+=this._utils.dataSizeBytes(t.number)),t.string!=null&&(e+=this._utils.dataSizeBytes(t.string)),t.json!=null&&(e+=this._utils.dataSizeBytes(t.json)),e}_decodeMapEntries(t,e,i){return Object.entries(t).reduce((a,s)=>{let[r,o]=s,c=o.data?this._decodeObjectData(o.data,e,i):void 0;return a[r]=m(j({},o),{data:c}),a},{})}_decodeObjectData(t,e,i){var a,s,r;try{let o;t.bytes!=null&&(o=i==="msgpack"?t.bytes:e.Platform.BufferUtils.base64Decode(String(t.bytes)));let c;return t.json!=null&&(c=JSON.parse(t.json)),{objectId:t.objectId,value:(r=(s=(a=o!=null?o:c)!=null?a:t.boolean)!=null?s:t.number)!=null?r:t.string}}catch(o){return e.Logger.logAction(e.logger,e.Logger.LOG_ERROR,"WireObjectMessage._decodeObjectData()",this._utils.inspectError(o)),j({},t)}}};var O=class{constructor(t,e){this._objects=t;this._client=this._objects.getClient(),this._subscriptions=new this._client.EventEmitter(this._client.logger),this._lifecycleEvents=new this._client.EventEmitter(this._client.logger),this._objectId=e,this._dataRef=this._getZeroValueData(),this._siteTimeserials={},this._createOperationIsMerged=!1,this._tombstone=!1}subscribe(t){return this._objects.throwIfInvalidAccessApiConfiguration(),this._subscriptions.on("updated",t),{unsubscribe:()=>{this._subscriptions.off("updated",t)}}}unsubscribe(t){this._client.Utils.isNil(t)||this._subscriptions.off("updated",t)}unsubscribeAll(){this._subscriptions.off("updated")}on(t,e){return this._lifecycleEvents.on(t,e),{off:()=>{this._lifecycleEvents.off(t,e)}}}off(t,e){this._client.Utils.isNil(t)&&this._client.Utils.isNil(e)||this._lifecycleEvents.off(t,e)}offAll(){this._lifecycleEvents.off()}getObjectId(){return this._objectId}notifyUpdated(t){t.noop||this._subscriptions.emit("updated",t)}tombstone(t){this._tombstone=!0,t.serialTimestamp!=null?this._tombstonedAt=t.serialTimestamp:(this._client.Logger.logAction(this._client.logger,this._client.Logger.LOG_MINOR,"LiveObject.tombstone()",`object has been tombstoned but no "serialTimestamp" found in the message, using local clock instead; objectId=${this.getObjectId()}`),this._tombstonedAt=Date.now());let e=this.clearData();return this._lifecycleEvents.emit("deleted"),e}isTombstoned(){return this._tombstone}tombstonedAt(){return this._tombstonedAt}clearData(){let t=this._dataRef;return this._dataRef=this._getZeroValueData(),this._updateFromDataDiff(t,this._dataRef)}_canApplyOperation(t,e){if(!t)throw new this._client.ErrorInfo(`Invalid serial: ${t}`,92e3,500);if(!e)throw new this._client.ErrorInfo(`Invalid site code: ${e}`,92e3,500);let i=this._siteTimeserials[e];return!i||t>i}_applyObjectDelete(t){return this.tombstone(t)}};var _=class n{constructor(t,e,i){this.type=t;this.hash=e;this.msTimestamp=i}static fromInitialValue(t,e,i,a,s){let r=t.BufferUtils.concat([t.BufferUtils.utf8Encode(i),t.BufferUtils.utf8Encode(":"),t.BufferUtils.utf8Encode(a)]),o=t.BufferUtils.sha256(r),c=t.BufferUtils.base64UrlEncode(o);return new n(e,c,s)}static fromString(t,e){if(t.Utils.isNil(e))throw new t.ErrorInfo("Invalid object id string",92e3,500);let[i,a]=e.split(":");if(!i||!a)throw new t.ErrorInfo("Invalid object id string",92e3,500);if(!["map","counter"].includes(i))throw new t.ErrorInfo(`Invalid object type in object id: ${e}`,92e3,500);let[s,r]=a.split("@");if(!s||!r)throw new t.ErrorInfo("Invalid object id string",92e3,500);if(!Number.isInteger(Number.parseInt(r)))throw new t.ErrorInfo("Invalid object id string",92e3,500);return new n(i,s,Number.parseInt(r))}toString(){return`${this.type}:${this.hash}@${this.msTimestamp}`}};var h=class n extends O{static zeroValue(t,e){return new n(t,e)}static fromObjectState(t,e){let i=new n(t,e.object.objectId);return i.overrideWithObjectState(e),i}static fromObjectOperation(t,e){let i=new n(t,e.objectId);return i._mergeInitialDataFromCreateOperation(e),i}static createCounterIncMessage(t,e,i){let a=t.getClient();if(typeof i!="number"||!Number.isFinite(i))throw new a.ErrorInfo("Counter value increment should be a valid number",40003,400);return b.fromValues({operation:{action:4,objectId:e,counterOp:{amount:i}}},a.Utils,a.MessageEncoding)}static async createCounterCreateMessage(t,e){let i=t.getClient();if(e!==void 0&&(typeof e!="number"||!Number.isFinite(e)))throw new i.ErrorInfo("Counter value should be a valid number",40003,400);let a=n.createInitialValueOperation(e),s=x(a,i),r=i.Utils.cheapRandStr(),o=await i.getTimestamp(!0),c=_.fromInitialValue(i.Platform,"counter",s,r,o).toString();return b.fromValues({operation:m(j({},a),{action:3,objectId:c,nonce:r,initialValue:s})},i.Utils,i.MessageEncoding)}static createInitialValueOperation(t){return{counter:{count:t!=null?t:0}}}value(){return this._objects.throwIfInvalidAccessApiConfiguration(),this._dataRef.data}async increment(t){this._objects.throwIfInvalidWriteApiConfiguration();let e=n.createCounterIncMessage(this._objects,this.getObjectId(),t);return this._objects.publish([e])}async decrement(t){if(this._objects.throwIfInvalidWriteApiConfiguration(),typeof t!="number"||!Number.isFinite(t))throw new this._client.ErrorInfo("Counter value decrement should be a valid number",40003,400);return this.increment(-t)}applyOperation(t,e){var r;if(t.objectId!==this.getObjectId())throw new this._client.ErrorInfo(`Cannot apply object operation with objectId=${t.objectId}, to this LiveCounter with objectId=${this.getObjectId()}`,92e3,500);let i=e.serial,a=e.siteCode;if(!this._canApplyOperation(i,a)){this._client.Logger.logAction(this._client.logger,this._client.Logger.LOG_MICRO,"LiveCounter.applyOperation()",`skipping ${t.action} op: op serial ${i.toString()} <= site serial ${(r=this._siteTimeserials[a])==null?void 0:r.toString()}; objectId=${this.getObjectId()}`);return}if(this._siteTimeserials[a]=i,this.isTombstoned())return;let s;switch(t.action){case 3:s=this._applyCounterCreate(t);break;case 4:if(this._client.Utils.isNil(t.counterOp)){this._throwNoPayloadError(t);return}else s=this._applyCounterInc(t.counterOp);break;case 5:s=this._applyObjectDelete(e);break;default:throw new this._client.ErrorInfo(`Invalid ${t.action} op for LiveCounter objectId=${this.getObjectId()}`,92e3,500)}this.notifyUpdated(s)}overrideWithObjectState(t){var a,s,r,o,c;let e=t.object;if(e==null)throw new this._client.ErrorInfo(`Missing object state; LiveCounter objectId=${this.getObjectId()}`,92e3,500);if(e.objectId!==this.getObjectId())throw new this._client.ErrorInfo(`Invalid object state: object state objectId=${e.objectId}; LiveCounter objectId=${this.getObjectId()}`,92e3,500);if(!this._client.Utils.isNil(e.createOp)){if(e.createOp.objectId!==this.getObjectId())throw new this._client.ErrorInfo(`Invalid object state: object state createOp objectId=${(a=e.createOp)==null?void 0:a.objectId}; LiveCounter objectId=${this.getObjectId()}`,92e3,500);if(e.createOp.action!==3)throw new this._client.ErrorInfo(`Invalid object state: object state createOp action=${(s=e.createOp)==null?void 0:s.action}; LiveCounter objectId=${this.getObjectId()}`,92e3,500)}if(this._siteTimeserials=(r=e.siteTimeserials)!=null?r:{},this.isTombstoned())return{noop:!0};let i=this._dataRef;return e.tombstone?this.tombstone(t):(this._createOperationIsMerged=!1,this._dataRef={data:(c=(o=e.counter)==null?void 0:o.count)!=null?c:0},this._client.Utils.isNil(e.createOp)||this._mergeInitialDataFromCreateOperation(e.createOp)),this._updateFromDataDiff(i,this._dataRef)}onGCInterval(){}_getZeroValueData(){return{data:0}}_updateFromDataDiff(t,e){return{update:{amount:e.data-t.data}}}_mergeInitialDataFromCreateOperation(t){var e,i,a,s;return this._dataRef.data+=(i=(e=t.counter)==null?void 0:e.count)!=null?i:0,this._createOperationIsMerged=!0,{update:{amount:(s=(a=t.counter)==null?void 0:a.count)!=null?s:0}}}_throwNoPayloadError(t){throw new this._client.ErrorInfo(`No payload found for ${t.action} op for LiveCounter objectId=${this.getObjectId()}`,92e3,500)}_applyCounterCreate(t){return this._createOperationIsMerged?(this._client.Logger.logAction(this._client.logger,this._client.Logger.LOG_MICRO,"LiveCounter._applyCounterCreate()",`skipping applying COUNTER_CREATE op on a counter instance as it was already applied before; objectId=${this.getObjectId()}`),{noop:!0}):this._mergeInitialDataFromCreateOperation(t)}_applyCounterInc(t){return this._dataRef.data+=t.amount,{update:{amount:t.amount}}}};var S=class{constructor(t,e,i){this._batchContext=t;this._objects=e;this._counter=i;this._client=this._objects.getClient()}value(){return this._objects.throwIfInvalidAccessApiConfiguration(),this._batchContext.throwIfClosed(),this._counter.value()}increment(t){this._objects.throwIfInvalidWriteApiConfiguration(),this._batchContext.throwIfClosed();let e=h.createCounterIncMessage(this._objects,this._counter.getObjectId(),t);this._batchContext.queueMessage(e)}decrement(t){if(this._objects.throwIfInvalidWriteApiConfiguration(),this._batchContext.throwIfClosed(),typeof t!="number")throw new this._client.ErrorInfo("Counter value decrement should be a number",40003,400);this.increment(-t)}};var Z=Object.prototype.hasOwnProperty;function Y(n,t,e){for(e of n.keys())if(y(e,t))return e}function y(n,t){var e,i,a;if(n===t)return!0;if(n&&t&&(e=n.constructor)===t.constructor){if(e===Date)return n.getTime()===t.getTime();if(e===RegExp)return n.toString()===t.toString();if(e===Array){if((i=n.length)===t.length)for(;i--&&y(n[i],t[i]););return i===-1}if(e===Set){if(n.size!==t.size)return!1;for(i of n)if(a=i,a&&typeof a=="object"&&(a=Y(t,a),!a)||!t.has(a))return!1;return!0}if(e===Map){if(n.size!==t.size)return!1;for(i of n)if(a=i[0],a&&typeof a=="object"&&(a=Y(t,a),!a)||!y(i[1],t.get(a)))return!1;return!0}if(e===ArrayBuffer)n=new Uint8Array(n),t=new Uint8Array(t);else if(e===DataView){if((i=n.byteLength)===t.byteLength)for(;i--&&n.getInt8(i)===t.getInt8(i););return i===-1}if(ArrayBuffer.isView(n)){if((i=n.byteLength)===t.byteLength)for(;i--&&n[i]===t[i];);return i===-1}if(!e||typeof n=="object"){i=0;for(e in n)if(Z.call(n,e)&&++i&&!Z.call(t,e)||!(e in t)||!y(n[e],t[e]))return!1;return Object.keys(t).length===i}}return n!==n&&t!==t}var d=class n extends O{constructor(e,i,a){super(e,a);this._semantics=i}static zeroValue(e,i){return new n(e,0,i)}static fromObjectState(e,i){let a=new n(e,i.object.map.semantics,i.object.objectId);return a.overrideWithObjectState(i),a}static fromObjectOperation(e,i){var s;let a=new n(e,(s=i.map)==null?void 0:s.semantics,i.objectId);return a._mergeInitialDataFromCreateOperation(i),a}static createMapSetMessage(e,i,a,s){let r=e.getClient();n.validateKeyValue(e,a,s);let o;return s instanceof O?o={objectId:s.getObjectId()}:o={value:s},b.fromValues({operation:{action:1,objectId:i,mapOp:{key:a,data:o}}},r.Utils,r.MessageEncoding)}static createMapRemoveMessage(e,i,a){let s=e.getClient();if(typeof a!="string")throw new s.ErrorInfo("Map key should be string",40003,400);return b.fromValues({operation:{action:2,objectId:i,mapOp:{key:a}}},s.Utils,s.MessageEncoding)}static validateKeyValue(e,i,a){let s=e.getClient();if(typeof i!="string")throw new s.ErrorInfo("Map key should be string",40003,400);if(a===null||typeof a!="string"&&typeof a!="number"&&typeof a!="boolean"&&typeof a!="object")throw new s.ErrorInfo("Map value data type is unsupported",40013,400)}static async createMapCreateMessage(e,i){let a=e.getClient();if(i!==void 0&&(i===null||typeof i!="object"))throw new a.ErrorInfo("Map entries should be a key-value object",40003,400);Object.entries(i!=null?i:{}).forEach(([u,f])=>n.validateKeyValue(e,u,f));let s=n.createInitialValueOperation(i),r=x(s,a),o=a.Utils.cheapRandStr(),c=await a.getTimestamp(!0),p=_.fromInitialValue(a.Platform,"map",r,o,c).toString();return b.fromValues({operation:m(j({},s),{action:0,objectId:p,nonce:o,initialValue:r})},a.Utils,a.MessageEncoding)}static createInitialValueOperation(e){let i={};return Object.entries(e!=null?e:{}).forEach(([a,s])=>{let r;s instanceof O?r={objectId:s.getObjectId()}:r={value:s},i[a]={data:r}}),{map:{semantics:0,entries:i}}}get(e){if(this._objects.throwIfInvalidAccessApiConfiguration(),this.isTombstoned())return;let i=this._dataRef.data.get(e);if(i!==void 0&&i.tombstone!==!0)return this._getResolvedValueFromObjectData(i.data)}size(){this._objects.throwIfInvalidAccessApiConfiguration();let e=0;for(let i of this._dataRef.data.values())this._isMapEntryTombstoned(i)||e++;return e}*entries(){this._objects.throwIfInvalidAccessApiConfiguration();for(let[e,i]of this._dataRef.data.entries()){if(this._isMapEntryTombstoned(i))continue;let a=this._getResolvedValueFromObjectData(i.data);yield[e,a]}}*keys(){for(let[e]of this.entries())yield e}*values(){for(let[e,i]of this.entries())yield i}async set(e,i){this._objects.throwIfInvalidWriteApiConfiguration();let a=n.createMapSetMessage(this._objects,this.getObjectId(),e,i);return this._objects.publish([a])}async remove(e){this._objects.throwIfInvalidWriteApiConfiguration();let i=n.createMapRemoveMessage(this._objects,this.getObjectId(),e);return this._objects.publish([i])}applyOperation(e,i){var o;if(e.objectId!==this.getObjectId())throw new this._client.ErrorInfo(`Cannot apply object operation with objectId=${e.objectId}, to this LiveMap with objectId=${this.getObjectId()}`,92e3,500);let a=i.serial,s=i.siteCode;if(!this._canApplyOperation(a,s)){this._client.Logger.logAction(this._client.logger,this._client.Logger.LOG_MICRO,"LiveMap.applyOperation()",`skipping ${e.action} op: op serial ${a.toString()} <= site serial ${(o=this._siteTimeserials[s])==null?void 0:o.toString()}; objectId=${this.getObjectId()}`);return}if(this._siteTimeserials[s]=a,this.isTombstoned())return;let r;switch(e.action){case 0:r=this._applyMapCreate(e);break;case 1:if(this._client.Utils.isNil(e.mapOp)){this._throwNoPayloadError(e);return}else r=this._applyMapSet(e.mapOp,a);break;case 2:if(this._client.Utils.isNil(e.mapOp)){this._throwNoPayloadError(e);return}else r=this._applyMapRemove(e.mapOp,a,i.serialTimestamp);break;case 5:r=this._applyObjectDelete(i);break;default:throw new this._client.ErrorInfo(`Invalid ${e.action} op for LiveMap objectId=${this.getObjectId()}`,92e3,500)}this.notifyUpdated(r)}overrideWithObjectState(e){var s,r,o,c,p,l,u,f,g;let i=e.object;if(i==null)throw new this._client.ErrorInfo(`Missing object state; LiveMap objectId=${this.getObjectId()}`,92e3,500);if(i.objectId!==this.getObjectId())throw new this._client.ErrorInfo(`Invalid object state: object state objectId=${i.objectId}; LiveMap objectId=${this.getObjectId()}`,92e3,500);if(((s=i.map)==null?void 0:s.semantics)!==this._semantics)throw new this._client.ErrorInfo(`Invalid object state: object state map semantics=${(r=i.map)==null?void 0:r.semantics}; LiveMap semantics=${this._semantics}`,92e3,500);if(!this._client.Utils.isNil(i.createOp)){if(i.createOp.objectId!==this.getObjectId())throw new this._client.ErrorInfo(`Invalid object state: object state createOp objectId=${(o=i.createOp)==null?void 0:o.objectId}; LiveMap objectId=${this.getObjectId()}`,92e3,500);if(i.createOp.action!==0)throw new this._client.ErrorInfo(`Invalid object state: object state createOp action=${(c=i.createOp)==null?void 0:c.action}; LiveMap objectId=${this.getObjectId()}`,92e3,500);if(((p=i.createOp.map)==null?void 0:p.semantics)!==this._semantics)throw new this._client.ErrorInfo(`Invalid object state: object state createOp map semantics=${(l=i.createOp.map)==null?void 0:l.semantics}; LiveMap semantics=${this._semantics}`,92e3,500)}if(this._siteTimeserials=(u=i.siteTimeserials)!=null?u:{},this.isTombstoned())return{noop:!0};let a=this._dataRef;return i.tombstone?this.tombstone(e):(this._createOperationIsMerged=!1,this._dataRef=this._liveMapDataFromMapEntries((g=(f=i.map)==null?void 0:f.entries)!=null?g:{}),this._client.Utils.isNil(i.createOp)||this._mergeInitialDataFromCreateOperation(i.createOp)),this._updateFromDataDiff(a,this._dataRef)}onGCInterval(){let e=[];for(let[i,a]of this._dataRef.data.entries())a.tombstone===!0&&Date.now()-a.tombstonedAt>=this._objects.gcGracePeriod&&e.push(i);e.forEach(i=>this._dataRef.data.delete(i))}_getZeroValueData(){return{data:new Map}}_updateFromDataDiff(e,i){let a={update:{}};for(let[s,r]of e.data.entries()){let o=s;r.tombstone===!1&&!i.data.has(o)&&(a.update[o]="removed")}for(let[s,r]of i.data.entries()){let o=s;if(!e.data.has(o)){if(r.tombstone===!1){a.update[o]="updated";continue}if(r.tombstone===!0)continue}let c=e.data.get(o);if(c.tombstone===!0&&r.tombstone===!1){a.update[o]="updated";continue}if(c.tombstone===!1&&r.tombstone===!0){a.update[o]="removed";continue}if(c.tombstone===!0&&r.tombstone===!0)continue;if(!y(c.data,r.data)){a.update[o]="updated";continue}}return a}_mergeInitialDataFromCreateOperation(e){var a;if(this._client.Utils.isNil(e.map))return{update:{}};let i={update:{}};return Object.entries((a=e.map.entries)!=null?a:{}).forEach(([s,r])=>{let o=r.timeserial,c;r.tombstone===!0?c=this._applyMapRemove({key:s},o,r.serialTimestamp):c=this._applyMapSet({key:s,data:r.data},o),!c.noop&&Object.assign(i.update,c.update)}),this._createOperationIsMerged=!0,i}_throwNoPayloadError(e){throw new this._client.ErrorInfo(`No payload found for ${e.action} op for LiveMap objectId=${this.getObjectId()}`,92e3,500)}_applyMapCreate(e){var i,a;if(this._createOperationIsMerged)return this._client.Logger.logAction(this._client.logger,this._client.Logger.LOG_MICRO,"LiveMap._applyMapCreate()",`skipping applying MAP_CREATE op on a map instance as it was already applied before; objectId=${this.getObjectId()}`),{noop:!0};if(this._semantics!==((i=e.map)==null?void 0:i.semantics))throw new this._client.ErrorInfo(`Cannot apply MAP_CREATE op on LiveMap objectId=${this.getObjectId()}; map's semantics=${this._semantics}, but op expected ${(a=e.map)==null?void 0:a.semantics}`,92e3,500);return this._mergeInitialDataFromCreateOperation(e)}_applyMapSet(e,i){var l;let{ErrorInfo:a,Utils:s}=this._client,r=this._dataRef.data.get(e.key);if(r&&!this._canApplyMapOperation(r.timeserial,i))return this._client.Logger.logAction(this._client.logger,this._client.Logger.LOG_MICRO,"LiveMap._applyMapSet()",`skipping update for key="${e.key}": op serial ${i==null?void 0:i.toString()} <= entry serial ${(l=r.timeserial)==null?void 0:l.toString()}; objectId=${this.getObjectId()}`),{noop:!0};if(s.isNil(e.data)||s.isNil(e.data.objectId)&&s.isNil(e.data.value))throw new a(`Invalid object data for MAP_SET op on objectId=${this.getObjectId()} on key="${e.key}"`,92e3,500);let o;if(s.isNil(e.data.objectId)?o={value:e.data.value}:(o={objectId:e.data.objectId},this._objects.getPool().createZeroValueObjectIfNotExists(e.data.objectId)),r)r.tombstone=!1,r.tombstonedAt=void 0,r.timeserial=i,r.data=o;else{let u={tombstone:!1,tombstonedAt:void 0,timeserial:i,data:o};this._dataRef.data.set(e.key,u)}let c={update:{}},p=e.key;return c.update[p]="updated",c}_applyMapRemove(e,i,a){var p;let s=this._dataRef.data.get(e.key);if(s&&!this._canApplyMapOperation(s.timeserial,i))return this._client.Logger.logAction(this._client.logger,this._client.Logger.LOG_MICRO,"LiveMap._applyMapRemove()",`skipping remove for key="${e.key}": op serial ${i==null?void 0:i.toString()} <= entry serial ${(p=s.timeserial)==null?void 0:p.toString()}; objectId=${this.getObjectId()}`),{noop:!0};let r;if(a!=null?r=a:(this._client.Logger.logAction(this._client.logger,this._client.Logger.LOG_MINOR,"LiveMap._applyMapRemove()",`map key has been removed but no "serialTimestamp" found in the message, using local clock instead; key="${e.key}", objectId=${this.getObjectId()}`),r=Date.now()),s)s.tombstone=!0,s.tombstonedAt=r,s.timeserial=i,s.data=void 0;else{let l={tombstone:!0,tombstonedAt:r,timeserial:i,data:void 0};this._dataRef.data.set(e.key,l)}let o={update:{}},c=e.key;return o.update[c]="removed",o}_canApplyMapOperation(e,i){return!e&&!i?!1:e?i?i>e:!1:!0}_liveMapDataFromMapEntries(e){let i={data:new Map};return Object.entries(e!=null?e:{}).forEach(([a,s])=>{let r;this._client.Utils.isNil(s.data)||(this._client.Utils.isNil(s.data.objectId)?r={value:s.data.value}:r={objectId:s.data.objectId});let o;s.tombstone===!0&&(s.serialTimestamp!=null?o=s.serialTimestamp:(this._client.Logger.logAction(this._client.logger,this._client.Logger.LOG_MINOR,"LiveMap._liveMapDataFromMapEntries()",`map key is removed but no "serialTimestamp" found, using local clock instead; key="${a}", objectId=${this.getObjectId()}`),o=Date.now()));let c={timeserial:s.timeserial,data:r,tombstone:s.tombstone===!0,tombstonedAt:o};i.data.set(a,c)}),i}_getResolvedValueFromObjectData(e){let i=e.value;if(i!=null)return i;let a=e.objectId,s=this._objects.getPool().get(a);if(s&&!s.isTombstoned())return s}_isMapEntryTombstoned(e){if(e.tombstone===!0)return!0;let i=e.data;if("objectId"in i){let a=this._objects.getPool().get(i.objectId);if(a!=null&&a.isTombstoned())return!0}return!1}};var T=class{constructor(t,e,i){this._batchContext=t;this._objects=e;this._map=i}get(t){this._objects.throwIfInvalidAccessApiConfiguration(),this._batchContext.throwIfClosed();let e=this._map.get(t);return e instanceof O?this._batchContext.getWrappedObject(e.getObjectId()):e}size(){return this._objects.throwIfInvalidAccessApiConfiguration(),this._batchContext.throwIfClosed(),this._map.size()}*entries(){this._objects.throwIfInvalidAccessApiConfiguration(),this._batchContext.throwIfClosed(),yield*P(this._map.entries())}*keys(){this._objects.throwIfInvalidAccessApiConfiguration(),this._batchContext.throwIfClosed(),yield*P(this._map.keys())}*values(){this._objects.throwIfInvalidAccessApiConfiguration(),this._batchContext.throwIfClosed(),yield*P(this._map.values())}set(t,e){this._objects.throwIfInvalidWriteApiConfiguration(),this._batchContext.throwIfClosed();let i=d.createMapSetMessage(this._objects,this._map.getObjectId(),t,e);this._batchContext.queueMessage(i)}remove(t){this._objects.throwIfInvalidWriteApiConfiguration(),this._batchContext.throwIfClosed();let e=d.createMapRemoveMessage(this._objects,this._map.getObjectId(),t);this._batchContext.queueMessage(e)}};var I={gcInterval:3e5,gcGracePeriod:864e5};var M="root",U=class{constructor(t){this._objects=t;var e,i;this._client=this._objects.getClient(),this._pool=this._createInitialPool(),this._gcInterval=setInterval(()=>{this._onGCInterval()},I.gcInterval),(i=(e=this._gcInterval).unref)==null||i.call(e)}get(t){return this._pool.get(t)}deleteExtraObjectIds(t){[...this._pool.keys()].filter(a=>!t.includes(a)).forEach(a=>this._pool.delete(a))}set(t,e){this._pool.set(t,e)}resetToInitialPool(t){let e=this._pool.get(M);this._pool.clear(),this._pool.set(e.getObjectId(),e),this.clearObjectsData(t)}clearObjectsData(t){for(let e of this._pool.values()){let i=e.clearData();t&&e.notifyUpdated(i)}}createZeroValueObjectIfNotExists(t){let e=this.get(t);if(e)return e;let i=_.fromString(this._client,t),a;switch(i.type){case"map":{a=d.zeroValue(this._objects,t);break}case"counter":a=h.zeroValue(this._objects,t);break}return this.set(t,a),a}_createInitialPool(){let t=new Map,e=d.zeroValue(this._objects,M);return t.set(e.getObjectId(),e),t}_onGCInterval(){let t=[];for(let[e,i]of this._pool.entries()){if(i.isTombstoned()&&Date.now()-i.tombstonedAt()>=this._objects.gcGracePeriod){t.push(e);continue}i.onGCInterval()}t.forEach(e=>this._pool.delete(e))}};var R=class{constructor(t,e){this._objects=t;this._root=e;this._wrappedObjects=new Map;this._queuedMessages=[];this._isClosed=!1;this._client=t.getClient(),this._wrappedObjects.set(this._root.getObjectId(),new T(this,this._objects,this._root))}getRoot(){return this._objects.throwIfInvalidAccessApiConfiguration(),this.throwIfClosed(),this.getWrappedObject(M)}getWrappedObject(t){if(this._wrappedObjects.has(t))return this._wrappedObjects.get(t);let e=this._objects.getPool().get(t);if(!e)return;let i;if(e instanceof d)i=new T(this,this._objects,e);else if(e instanceof h)i=new S(this,this._objects,e);else throw new this._client.ErrorInfo(`Unknown LiveObject instance type: objectId=${e.getObjectId()}`,5e4,500);return this._wrappedObjects.set(t,i),i}throwIfClosed(){if(this.isClosed())throw new this._client.ErrorInfo("Batch is closed",4e4,400)}isClosed(){return this._isClosed}close(){this._isClosed=!0}queueMessage(t){this._queuedMessages.push(t)}async flush(){try{this.close(),this._queuedMessages.length>0&&await this._objects.publish(this._queuedMessages)}finally{this._wrappedObjects.clear(),this._queuedMessages=[]}}};var N=class{constructor(t){this._objects=t;this._client=this._objects.getClient(),this._channel=this._objects.getChannel(),this._pool=new Map}entries(){return this._pool.entries()}size(){return this._pool.size}isEmpty(){return this._pool.size===0}clear(){this._pool.clear()}applyObjectSyncMessages(t){for(let e of t){if(!e.object){this._client.Logger.logAction(this._client.logger,this._client.Logger.LOG_MAJOR,"SyncObjectsDataPool.applyObjectSyncMessages()",`object message is received during OBJECT_SYNC without 'object' field, skipping message; message id: ${e.id}, channel: ${this._channel.name}`);continue}let i=e.object;i.counter?this._pool.set(i.objectId,this._createLiveCounterDataEntry(e)):i.map?this._pool.set(i.objectId,this._createLiveMapDataEntry(e)):this._client.Logger.logAction(this._client.logger,this._client.Logger.LOG_MAJOR,"SyncObjectsDataPool.applyObjectSyncMessages()",`received unsupported object state message during OBJECT_SYNC, expected 'counter' or 'map' to be present, skipping message; message id: ${e.id}, channel: ${this._channel.name}`)}}_createLiveCounterDataEntry(t){return{objectMessage:t,objectType:"LiveCounter"}}_createLiveMapDataEntry(t){return{objectMessage:t,objectType:"LiveMap"}}};var ne={initialized:void 0,syncing:"syncing",synced:"synced"},E=class{constructor(t){var e,i;this._channel=t,this._client=t.client,this._state="initialized",this._eventEmitterInternal=new this._client.EventEmitter(this._client.logger),this._eventEmitterPublic=new this._client.EventEmitter(this._client.logger),this._objectsPool=new U(this),this._syncObjectsDataPool=new N(this),this._bufferedObjectOperations=[],this.gcGracePeriod=(i=(e=this._channel.connectionManager.connectionDetails)==null?void 0:e.objectsGCGracePeriod)!=null?i:I.gcGracePeriod,this._channel.connectionManager.on("connectiondetails",a=>{var s;this.gcGracePeriod=(s=a.objectsGCGracePeriod)!=null?s:I.gcGracePeriod})}async getRoot(){return this.throwIfInvalidAccessApiConfiguration(),this._state!=="synced"&&await this._eventEmitterInternal.once("synced"),this._objectsPool.get(M)}async batch(t){this.throwIfInvalidWriteApiConfiguration();let e=await this.getRoot(),i=new R(this,e);try{t(i),await i.flush()}finally{i.close()}}async createMap(t){var s;this.throwIfInvalidWriteApiConfiguration();let e=await d.createMapCreateMessage(this,t),i=(s=e.operation)==null?void 0:s.objectId;if(await this.publish([e]),this._objectsPool.get(i))return this._objectsPool.get(i);let a=d.fromObjectOperation(this,e.operation);return this._objectsPool.set(i,a),a}async createCounter(t){var s;this.throwIfInvalidWriteApiConfiguration();let e=await h.createCounterCreateMessage(this,t),i=(s=e.operation)==null?void 0:s.objectId;if(await this.publish([e]),this._objectsPool.get(i))return this._objectsPool.get(i);let a=h.fromObjectOperation(this,e.operation);return this._objectsPool.set(i,a),a}on(t,e){return this._eventEmitterPublic.on(t,e),{off:()=>{this._eventEmitterPublic.off(t,e)}}}off(t,e){this._client.Utils.isNil(t)&&this._client.Utils.isNil(e)||this._eventEmitterPublic.off(t,e)}offAll(){this._eventEmitterPublic.off()}getPool(){return this._objectsPool}getChannel(){return this._channel}getClient(){return this._client}handleObjectSyncMessages(t,e){let{syncId:i,syncCursor:a}=this._parseSyncChannelSerial(e),s=this._currentSyncId!==i;s&&this._startNewSync(i,a),this._syncObjectsDataPool.applyObjectSyncMessages(t),a||this._endSync(s)}handleObjectMessages(t){if(this._state!=="synced"){this._bufferedObjectOperations.push(...t);return}this._applyObjectMessages(t)}onAttached(t){this._client.Logger.logAction(this._client.logger,this._client.Logger.LOG_MINOR,"Objects.onAttached()",`channel=${this._channel.name}, hasObjects=${t}`);let e=this._state==="initialized";(t||e)&&this._startNewSync(),t||(this._objectsPool.resetToInitialPool(!0),this._syncObjectsDataPool.clear(),this._endSync(e))}actOnChannelState(t,e){switch(t){case"attached":this.onAttached(e);break;case"detached":case"failed":this._objectsPool.clearObjectsData(!1),this._syncObjectsDataPool.clear();break}}async publish(t){this._channel.throwIfUnpublishableState();let e=t.map(s=>s.encode(this._client)),i=this._client.options.maxMessageSize,a=e.reduce((s,r)=>s+r.getMessageSize(),0);if(a>i)throw new this._client.ErrorInfo(`Maximum size of object messages that can be published at once exceeded (was ${a} bytes; limit is ${i} bytes)`,40009,400);return this._channel.sendState(e)}throwIfInvalidAccessApiConfiguration(){this._throwIfMissingChannelMode("object_subscribe"),this._throwIfInChannelState(["detached","failed"])}throwIfInvalidWriteApiConfiguration(){this._throwIfMissingChannelMode("object_publish"),this._throwIfInChannelState(["detached","failed","suspended"]),this._throwIfEchoMessagesDisabled()}_startNewSync(t,e){this._bufferedObjectOperations=[],this._syncObjectsDataPool.clear(),this._currentSyncId=t,this._currentSyncCursor=e,this._stateChange("syncing",!1)}_endSync(t){this._applySync(),this._applyObjectMessages(this._bufferedObjectOperations),this._bufferedObjectOperations=[],this._syncObjectsDataPool.clear(),this._currentSyncId=void 0,this._currentSyncCursor=void 0,this._stateChange("synced",t)}_parseSyncChannelSerial(t){let e,i,a;return t&&(e=t.match(/^([\w-]+):(.*)$/))&&(i=e[1],a=e[2]),{syncId:i,syncCursor:a}}_applySync(){if(this._syncObjectsDataPool.isEmpty())return;let t=new Set,e=[];for(let[i,a]of this._syncObjectsDataPool.entries()){t.add(i);let s=this._objectsPool.get(i);if(s){let c=s.overrideWithObjectState(a.objectMessage);e.push({object:s,update:c});continue}let r,o=a.objectType;switch(o){case"LiveCounter":r=h.fromObjectState(this,a.objectMessage);break;case"LiveMap":r=d.fromObjectState(this,a.objectMessage);break;default:throw new this._client.ErrorInfo(`Unknown LiveObject type: ${o}`,5e4,500)}this._objectsPool.set(i,r)}this._objectsPool.deleteExtraObjectIds([...t]),e.forEach(({object:i,update:a})=>i.notifyUpdated(a))}_applyObjectMessages(t){for(let e of t){if(!e.operation){this._client.Logger.logAction(this._client.logger,this._client.Logger.LOG_MAJOR,"Objects._applyObjectMessages()",`object operation message is received without 'operation' field, skipping message; message id: ${e.id}, channel: ${this._channel.name}`);continue}let i=e.operation;switch(i.action){case 0:case 3:case 1:case 2:case 4:case 5:this._objectsPool.createZeroValueObjectIfNotExists(i.objectId),this._objectsPool.get(i.objectId).applyOperation(i,e);break;default:this._client.Logger.logAction(this._client.logger,this._client.Logger.LOG_MAJOR,"Objects._applyObjectMessages()",`received unsupported action in object operation message: ${i.action}, skipping message; message id: ${e.id}, channel: ${this._channel.name}`)}}}_throwIfMissingChannelMode(t){var e;if(this._channel.modes!=null&&!this._channel.modes.includes(t))throw new this._client.ErrorInfo(`"${t}" channel mode must be set for this operation`,40024,400);if(!this._client.Utils.allToLowerCase((e=this._channel.channelOptions.modes)!=null?e:[]).includes(t))throw new this._client.ErrorInfo(`"${t}" channel mode must be set for this operation`,40024,400)}_stateChange(t,e){if(this._state===t)return;this._state=t;let i=ne[t];i&&(e?this._client.Platform.Config.nextTick(()=>{this._eventEmitterInternal.emit(i),this._eventEmitterPublic.emit(i)}):(this._eventEmitterInternal.emit(i),this._eventEmitterPublic.emit(i)))}_throwIfInChannelState(t){if(t.includes(this._channel.state))throw this._client.ErrorInfo.fromValues(this._channel.invalidStateError())}_throwIfEchoMessagesDisabled(){if(this._channel.client.options.echoMessages===!1)throw new this._channel.client.ErrorInfo('"echoMessages" client option must be enabled for this operation',4e4,400)}};E._DEFAULTS=I;var re={Objects:E,ObjectMessage:b,WireObjectMessage:v};
if (typeof module.exports == "object" && typeof exports == "object") {
  var __cp = (to, from, except, desc) => {
    if ((from && typeof from === "object") || typeof from === "function") {
      for (let key of Object.getOwnPropertyNames(from)) {
        if (!Object.prototype.hasOwnProperty.call(to, key) && key !== except)
        Object.defineProperty(to, key, {
          get: () => from[key],
          enumerable: !(desc = Object.getOwnPropertyDescriptor(from, key)) || desc.enumerable,
        });
      }
    }
    return to;
  };
  module.exports = __cp(module.exports, exports);
}
return module.exports;
}))
//# sourceMappingURL=objects.umd.min.js.map
